# 第6章 函数

我们知道圆的面积计算公式为：


S = $πr^2$

当我们知道半径`r`的值时，就可以根据公式计算出面积。假设我们需要计算3个不同大小的圆的面积：

```
let r1 = 12.34;
let r2 = 9.08;
let r3 = 73.1;
let s1 = 3.14 * r1 * r1;
let s2 = 3.14 * r2 * r2;
let s3 = 3.14 * r3 * r3;
```

当代码出现有规律的重复的时候，你就需要当心了，每次写`3.14 * x * x`不仅很麻烦，而且，如果要把`3.14`改成`3.14159265359`的时候，得全部替换。

有了函数，我们就不再每次写`s = 3.14 * x * x，`而是写成更有意义的函数调用`s = area_of_circle(x)`，而函数`area_of_circle`本身只需要写一次，就可以多次调用。

基本上所有的高级语言都支持函数，JavaScript也不例外。JavaScript的函数不但是“头等公民”，而且可以像变量一样使用，具有非常强大的抽象能力。

抽象是数学中非常常见的概念。举个例子：

计算数列的和，比如：`1 + 2 + 3 + ... + 100`，写起来十分不方便，于是数学家发明了求和符号`∑`，可以把`1 + 2 + 3 + ... + 100`记作：

$$\sum_{n=1}^{100}n$$

这种抽象记法非常强大，因为我们看到 ∑ 就可以理解成求和，而不是还原成低级的加法运算。

而且，这种抽象记法是可扩展的，比如：

$$\sum_{n=1}^{100}(n^2+1)$$

还原成加法运算就变成了：

```
(1 x 1 + 1) + (2 x 2 + 1) + (3 x 3 + 1) + ... + (100 x 100 + 1)
```

可见，借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。

写计算机程序也是一样，函数就是最基本的一种代码抽象的方式。



## 6.1 函数基础

函数由函数定义和函数调用两部分组成，应首先定义函数，然后再进行调用，以养成良好的编程习惯。
函数的定义应使用关键字 function，其语法规则如下：```
function funcName () {	statements;}
```函数的各部分含义如下：* funcName 为函数名，函数名可由开发者自行定义，与变量的命名规则基本相同；
* statements 是函数体，规定了函数的功能，本质上相当于一个脚本程序；

例如：

```
function logStar(){
	console.log('***')
}
```

定义函数的代码并不会运行。需要调用函数才可以运行函数体中的代码。在函数定义结束之后的代码空间中，便可以调用该函数。

调用函数的方法即`函数名()`的方式。

```
logStar();
```

我们看如下代码：

```
console.log(1);

function logStar(){
	console.log('***')
}

console.log(2);

logStar();

console.log(3);
```
这段代码的运行结果为

```
1
2
***
3
```
可以看出，代码默认是自上而下的一行一行的运行。但函数定义中函数体的代码并不会运行，只有在函数调用时，函数体的代码才真正运行。且函数可以多次调用，每次调用的结果相互独立。

## 6.2 函数参数与返回值

### 6.2.1 函数参数

在定义函数时，可以在函数名后面的括号中定义多个变量，变量间用逗号分隔。这些变量称为函数参数。

在函数体中，可以直接使用这些函数参数。

```
function add(x,y){
	const sum = x + y;
	console.log(sum);
}
```
参数变量的值由函数调用时指定，根据位置对应关系赋值。

```
add(1,2);
```
如此调用时，函数的第一个参数x的值为1，第二个参数y的值为2；

这里需要强调**函数参数复制只与位置相关，和变量名无关**

阅读如下代码：

```
function funcA(x,y){
	console.log(x);
	console.log(y);
}

const x = 1;
const y = 2;

funcA(y,x);
```

以上代码运行结果为：`2  1`。在函数调用时，将第一个参数位置上的y复制给函数的第一个参数x，以位置关系进行对应赋值。

在使用函数参数时，需要注意**函数参数的传递过程为值复制过程。**

在看下面代码

```
function funcX(x){
	x = 0;
}

let x = 1;
funcX(x);
console.log(x);
```
以上代码运行结果为:`1`。

这里函数中的变量`x`和函数外的变量`x`是两个变量，在函数调用过程中，仅将一个变量的值复制到另一个变量，之后这两个变量便在无联系。所以改变函数内的变量不会影响函数外变量的值。

JavaScript语言允许在定义函数参数时指定函数参数的默认值：

```
function logX(x = 0){
	console.log(x);
}
```
在调用函数时，如没有给定函数参数值，函数即使用默认值作为函数参数。

```
logX();//输出0

logX(1);//输出1
```

### 6.2.2 函数返回值

JavaScript语言中，函数可以通过`return`关键字返回其内部的数据，作为函数表达式的值。

例如：

```
function add(x,y){
	const sum = x + y;
	return sum;
}

const s = add(1,2);
console.log(s);
```
在上述代码中，函数表达式`add(1,2)`的值由函数体中的`return`决定。

`return`不仅提供函数表达式的值，还有结束函数的作用。在没有`return`的函数中，函数运行到大括号结束。但如遇到`return`函数也随之结束，即`return`后面的语句不会执行。

例如：

```
function funcA(){
	console.log(1);
	return 0;
	console.log(2);
}

const r = funcA();
```
以上代码运行结果为：`1`。因`return`关键字提前结束函数。

```
function funcB(){
	return 0;
	return 1;
}
const r = funcB();
console.log(r);
```

以上代码运行结果为：`0`,因第一个`return`决定函数表达式为`0`且结束函数，第二个`return`未运行。


如果函数可能返回多种不同结果，可以使用分支语句。

```
function funcC(x){
	if(x >= 0){
		return '输入参数为正数';
	} else {
		return '输入参数为负数';
	}
}

funcC(1);
funcC(-1);
```
以上运行结果为

```
输入参数为正数
输入参数为负数
```


## 6.3 函数作用域

在JavaScript语言中，函数和变量具有同样的作用域特性，在相同作用域下的的函数体内部可以访问外部的变量。但函数参数和变量名相同时，函数体内部无法访问外包同名变量。

看如下代码的区别：

```
function funcA(x){
	x++;
}

let x = 1;
funcA(x);
console.log(x);
```
此代码运行结果为:`1`

```
function funcA(){
	x++;
}

let x = 1;
funcA(x);
console.log(x);
```
此代码运行结果为:`2`

以上两段代码的区别就是在函数中定义了一个与外部变量同名的参数。在有这个参数时，函数体内部访问的是这个参数，和外部变量无关。在这个参数不存在时，根据作用域的规则，函数体内部可以访问到外部变量。

**通常我们规定，不允许在函数体内部修改外部变量的值，但可以读取外部变量的值，以免产生很多意想不到的错误**

## 6.4 箭头函数

ES6增加箭头函数特性，通过箭头语法声明一个函数，此函数没有函数名，只有参数和函数体。

```
(x,y)=>{
	return x + y;
}
```

定义好的箭头函数不能直接使用，需要借助变量才能够调用箭头函数。

```
//将箭头函数赋值给一个变量
const aFunc = (x)=>{
	console.log(x);
}
//通过储存箭头函数的变量调用该箭头函数

aFunc(1);//输出：1

```

## 6.5 函数对象

在JavaScript中，变量可以储存一个值，一个对象和一个数组。同样变量还可以储存一个函数，储存函数的变量，我们称之为函数对象。

创建函数对象有两种方式：

* 通过箭头函数创建函数对象
* 通过普通函数创建函数对象

```
//将定义好的箭头函数赋值给一个变量，这个变量即成为函数对象
const funcObj1 = (x)=>{
	console.log(x);
}

function func2(x){
	console.log(x);
}

//将一个定义好的普通函数的函数名赋值给一个变量，
//这个变量也为函数对象
const funcObj2 = func2;

```

通过函数对象可以调用其储存的函数体，并传递参数接收返回值

```
const func1 = ()=>{
	console.log('test1');
}

func1();//输出 test1

```

```
const func2 = (x)=>{
	console.log(x);
}

func2(11);//输出 11
```

```
const func3 = (x,y)=>{
	return x+y;
}

const sum = func3(1,2);
console.log(sum);//输出 3
```

## 6.6 高阶函数

高阶函数本质为函数，只是函数参数的类型中含有函数对象。例如：

```
function func1(f1){
	f1();
}
```
在JavaScript定义函数时，无需对函数参数的类型进行声明，所有该函数参数是否为函数对象还是普通对象，需要通过阅读函数体代码或者注释进行。

在函数体内，有对函数参数进行调用的语句(参数后加了一对小括号)，那么可以说明，该参数为函数对象，此函数为高阶函数，我们可以简单说，高阶函数就是调用函数对象的函数。

```
//创建一个函数对象
const f = ()=>{
	console.log('hello');
}

//通过高阶函数func1调用函数对象f
func1(f);//输出结果  hello
```

所以，高阶函数本质是一个非常简单的概念，也很好掌握，关键难度在与应用场景。

大家看到现在可能会有一个疑问，一个函数对象，在代码中，可以直接调用，但为什么要使用一个高阶函数进行调用，为什么要使用这么麻烦的方式？

解答这个问题，我们需要先引出更复杂的需求。在上述打印`hello`的案例中，使用高阶函数确实是一个画蛇添足的过程，但是在遇到复杂问题时，高阶函数是一个非常好的工具。


### 6.6.1 抽象封装


首先我们来说重复过程，这里说的不是一件事的重复过程，而是一类事的重复过程。

例如，对数组进行排序，数组培训的步骤非常多，而且不同数组，不同培训规则的代码也不一样。


```
//用冒泡法对数组arr1进行升序排列
const arr1 = [1,5,2,4,3];

for(let i=0;i<arr1.length-1;i++)    
{
	for(let j=i+1;j<i<arr1.length;j++) {
		//升序or降序
		if(a[j-1]>a[j]) {  
			let t=a[j];  
			a[j]=a[j+1];  
			a[j+1]=t; 
		} 
	}  
}  
```

```
//用冒泡法对数组arr1进行降序排列
const arr1 = [1,5,2,4,3];

for(let i=0;i<arr1.length-1;i++)    
{
	for(let j=i+1;j<i<arr1.length;j++) {
		//升序or降序
		if(a[j-1]<a[j]) {  
			let t=a[j];  
			a[j]=a[j+1];  
			a[j+1]=t; 
		} 
	}  
}  
```
通过阅读这两个排序代码，我们发现排序操作的过程很多，但大多都一样，只有一步不同，就是对升序还是降序的控制语句。

**这种的情况，我们就可以使用高阶函数，将排序这一类事物的相同操作部分进行封装，而不同操作部分定义为一个函数对象，其具体操作有使用者编写**

定义高阶函数，封装操作过程

```
function sort(arr,f){
	for(let i=0;i<arr1.length-1;i++)    
	{
		for(let j=i+1;j<i<arr1.length;j++) {
			//升序or降序,通过调用函数对象f进行获取
			//函数对象f由此函数使用者提供
			const result = f(a[j-1],a[j]);
			if(result) {  
				let t=a[j];  
				a[j]=a[j+1];  
				a[j+1]=t; 
			} 
		}  
	} 
	return arr;
}
```

使用高阶函数

```
//构造函数对象，封装操作过程，指定排序规则为升序
const func = (x,y)=>{
	return x>y;
}
//准备数据
const arr = [1,2,3,4];
//调用高阶函数，传入函数对象
const s_arr = sort(arr,func);
```
通过高阶函数封装了数组的排序过程，在使用其对数组进行排序时，只需要制定排序规则即可。


### 6.6.2，回调函数

讲解回调函数之前，我们首先看一个简单的案例

```
//案例1
//创建一个函数，打印1,2,3三个数

function log(){
	console.log(1);
	console.log(2);
	console.log(3);
}

log();//输出 1 2 3
```

这个案例比较简单，就是通过函数封装了三个输出操作。我们继续看下一个少难一点的案例

```
//案例2
//创建一个函数，先打印1，在打印一个x的值，在打印3
//x的值在创建函数的时候不知道是多少

function log(x){
	console.log(1);
	console.log(x);
	console.log(3);
}
```

我们看案例1和案例2的区别，这两个案例都是通过一个函数封装操作，但案例中的每个操作都是明确的，在编程的时候已知所有信息，而案例2中的操作，编程的时候，有部分信息是未知的。

但案例2我们仍然可以处理，因为位置的是一个值，我们可以用变量去表示这个值，在使用`log`函数时，为这个变量赋值即可。

案例1的编程模式，我们称之为**静态编程**，即编程的时候已知所有信息。案例2的编程模式，我们称之为**动态编程**，即编程的时候有部分信息未知。

通过变量，我们可以处理值未知的动态问题。例如

```
//构造一个函数，求两个数的和
//在编程函数是，不知道是哪两个数，是动态编程
//所以我们使用变量进行处理，定义x，y两个变量作为函数参数
function add(x,y){
	return x+y;
}
```

同时，通过函数对象，我们可以处理未知事件问题，例如：

```
//构造一个函数，要求如下：
//首先打印一个1，然后执行一个操作，然后打印一个2
//执行的操作在编程中未知，我们用一个函数对象表示这个未知的操作

function doSomething(func){
	console.log(1);
	func();//调用函数对象，即表示执行函数对象中封装的操作
	console.log(3);
}
```

使用这个函数执行相应事件

```
//首先构造函数对象，封装所要执行的事件
const f = ()=>{
	console.log(2);
}
//调用函数执行
doSomething(f);//输出1 2 3
```
看到这里，大家心里可能会产生一个疑问。

```
function log(){
	console.log(1);
	console.log(2);
	console.log(3);
}

log();//输出 1 2 3
```
```
function doSomething(func){
	console.log(1);
	func();//调用函数对象，即表示执行函数对象中封装的操作
	console.log(3);
}

const f = ()=>{
	console.log(2);
}

doSomething(f);//输出1 2 3
```
以上两段代码都是输出1 2 3 为何下面的代码这么复杂。

首先我们看下面一段代码，可是分为两个部分

```
function doSomething(func){
	console.log(1);
	func();//调用函数对象，即表示执行函数对象中封装的操作
	console.log(3);
}
```
```
const f = ()=>{
	console.log(2);
}

doSomething(f);//输出1 2 3
```
分为这两个部分之后，我们在来看，如果现在需求变化了，我们需要输出1 5 3

那么，如果是原来的代码，我们需要对其函数内部进行修改

```
function log(){
	console.log(1);
	console.log(5);
	console.log(3);
}
```
而分成两段的复杂代码，我们只需要重写下一段代码即可实现

```
const f = ()=>{
	console.log(5);
}

doSomething(f);//输出1 5 3
```
而上面一段代码无需进行任何修改。

这样不需要修改代码，而能够使其适应各种使用场景的基础代码是非常重要的。

因为我们在真实的开发中，不是从零开始开发所有的东西，我们会使用各种框架，而框架中会提供各种基础操作，我们只需要在框架基础操作上面定制我们所需要的功能。这种定制就是基于此知识点实现的。

例如我们以后会使用ReactNative框架，其提供了一个按钮组件，在编写按钮组件时，编写人员并不知道你会在按钮点击时执行什么样的代码，但这并不影响按钮组件的开发，开发人员只需要通过一个函数对象做为未知事件的变量。

例如：

```
ReactNative API
//onClick为一个函数对象，当按钮被点击时被执行
button(onClick);
```
那么我们就可以使用该按钮

```
const loginAciton = ()=>{
	console.log('登录');//模拟登录
}
button(loginAciton);
```
```
const postAciton = ()=>{
	console.log('发微博');//模拟登录
}
button(postAciton);
```
虽然点击按钮执行的是不同的功能，但是我们不需要更改按钮的任何一行代码。**这个函数的参数就是回调函数，本质为一个函数对象的形参。**

## 6.7 函数闭包

闭包是一个即使父级作用域关闭之后仍然能对其访问的函数。

JavaScript 中创建的函数，可以访问函数内以及函数外的变量。

函数内部定义的变量是定义在局部的变量。局部变量只能在定义它的函数内部(作用域)访问到。在下面的示例中，如果我们尝试在函数外面输出words的值，会得到一个引用错误。因为words是一个存在于局部作用域的变量：

```
// Example of accessing variables INSIDE the function
// words is a LOCAL variable
function speak(){
    const words = 'hi';
    console.log(words);
}
speak(); // 'hi'
console.log(words); // Uncaught ReferenceError: words is not defined
```

与上面的例子不同，下面例子中的words是定义在全局作用域的。也就是说，它可以被文档中的所有函数访问到。

```
// Example of accessing variables OUTSIDE the function
// words is a GLOBAL variable
var words = 'hi';
function speak(){
    console.log(words);
}
speak(); // 'hi' 
console.log(words); // 'hi'
```

如果我们把一个函数嵌套在另一个函数中会怎样？

```
function speak() {
    return function logIt() {
        var words = 'hi';
        console.log(words);
   }
}

//调用函数得到返回值为一个函数对象
const sayHello = speak();
//调用此函数对象等效于调用logIt()函数
sayHello();//hi
```

这并没有什么特别。现在我们移动一行代码看看会有什么变化。看下面的例子。我们把声明变量words的语句移到了内部函数的外面，在speak()函数中：

```
function speak() {
    var words = 'hi';
    return function logIt() {
        console.log(words);
   }
}

```

跟之前一样，声明一个变量并从 speak 函数赋值给它：

```
const sayHello = speak();

console.log(sayHello);
```
输出结果为

```
function logIt() {
   console.log(words);
}
```
发现`sayHello`是一个函数对象，函数对象中引用了一个没有定义的变量`words`。

那么我们现在调用这个函数对象会发生什么情况？

```
sayHello();//没有运行错误，打印输出hi
```

我们重新看一下闭包的定义：**闭包是一个即使父级作用域关闭之后仍然能对其访问的函数。**

这个示例中`speak()`函数的作用域已经闭包了。因此`const words = 'hi'`应该不存在了。然而，在 JavaScript 中存在着一个称为闭包的很酷的小概念：内部函数维护着一个创建它的作用域的引用。这样即使在`speak()`关闭之后，`logIt()`函数仍然可以访问`words`变量。

>JavaScript 中的每个函数都存在闭包，这很重要。你不需要专门对函数做什么事来使其生效。它就是 JavaScript 的一部分。

我们再看一个例子。这个例子会稍微复杂一点。代码如下：

```
function name(n) {
    return function(a) {
        return `${n} likes ${a}`;
   };
}
```

我们有一个函数name，它需要一个参数，然后返回一个需要不同函数的匿名函数。内部函数最终会返回字符串。

然后调用两次name函数。第一次传入名字 John，另一个传入 Cindy：

```
var j = name('John');
var c = name('Cindy');
```

在运行：

```
j('dogs');  // 'John likes dogs'
c('cats');  // 'Cindy likes cats'
```

因为闭包，我们可以成功执行引用了已关闭作用域中变量的函数。

## 项目实战：抽签系统

### 项目背景

在互联网商业营销中，利用抽签选出一个幸运用户赠与奖品是非常普遍的营销手段，也是和用户充分互动的营销策略。

在抽签系统中，需要用户首先进行登记。登记之后的用户便拥有了被抽中的权利。但在登记过程中，部分用户进行重复登记，致使在抽签池中该用户的数据增加，随之被抽中的机会也增加，如放任此中情况，那么会有用户借助技术手段，生成大量登记信息，使抽签的概率被人为操作，失去随机的意义。

在抽签系统中，去除重复是非常重要的一个环节，去重的维度可以很多。比如有些用户虽然使用了不同的账号进行登录，但联系方式都一样，有明细的刷票行为，这样的特征应作为去重的指标。

### 项目技术要求

此去重系统为单一的`id`去重，不涉及更多维度。将客户提供的存储`id`的数据中，重复的`id`去掉，返回一个没有重复`id`的数据。

例如客户提供数据为：

```
1,2,3,4,5,6,7,8,2,4,6
```

在经过系统处理之后，应返回为：

```
1,2,3,4,5,6,7,8
```

### 系统技术设计

此种数据处理问题中，需要根据数据量的级别进行不同的算法设计，以满足效率的要求。

* 小数据量，采用数组遍历模式，在向数组加入数据之前，先遍历该数组是否包含这个元素，如果包含则不加入。这种算法优点是简单，实现快速，但缺点是在大数据量时，时间复杂度成指数增加，无法满足系统要求。
* 中等数据量，采用先排序后筛选的模式，这里采用冒泡排序，排序时间稳定，复杂度不高。排序之后对数据进行筛选，只需筛选相邻数据即可，效率快速提升，可以满足中等数据量的处理性能要求。
* 大数据量，采用数组下标发进行数据筛选，然后进行数据识别与恢复，此种算法只适用于纯数字数据的去重处理，与此项目的要求相符，在大数据量下，可以满足系统性能指标的要求。


### 小数据量系统实现

一般数据量在千以下的级别可以称为小数据量。首先构造一个测试数据。

```
const users = [1,2,3,4,5,6,7,8,9,1,1,1,2,3,5,6];
```
>构造测试数据时尽量覆盖尽可能多的情况。

```
//创建一个数组，储存筛选后的结果，该数组中元素值唯一
const result = [];

//对原始数据数组进行遍历
for(let i=0;i<users.length;i++){
	//获取需要添加的数据元素
	const id = users[i];
	//用result数组对该数据元素进行判断
	let isExist = false;
	//遍历结果数组
	for(let i=0;i<result.length;i++){
		if(result[i] == id){
			isExist = true;
			break;
		}
	}
	//如该数据不存在，则添加该数据到结果数组
	if(isExist == false){
		result.push(id)
	}
}

//输出结果
console.log(result)
```

### 中等数据量实现

通常情况，小于10万级的数据量，我们可以称为中等数据量。在中等数据量时，不能够在使用数组遍历的方式进行去重，因数组遍历的计算过程会随着数据量增加而成指数形式上升。

此种情况下，我们先对数据进行排序，然后将排序后的数据依次放入结果数组并去重。

```
const users = [1,2,3,4,5,6,7,8,9,1,1,1,2,3,5,6];

//对原始数据进行排序，采用冒泡法
const n = users.length;
for(let j=0;j<n-1;j++){
	for(let i=0;i<n-1-j;i++){
		if(users[i]>users[i+1]){
			let temp = users[i];
			users[i] = users[i+1];
			users[i+1] = temp;
		}
	}
}

//输出排序结果
console.log(users);


const results = [];
let tempId = null;

//对数据进行去重操作
for(let i=0;i<n;i++){
	if(tempId != users[i]){
		results.push(users[i]);
		tempId = users[i];
	}
}

//输出最终结果
console.log(results);

```

结果输出

```
[1,1,1,1,2,2,3,3,4,5,5,6,6,7,8,9]
[1,2,3,4,5,6,7,8,9]
```

### 大数据量实现

当数据量超过10万级时，普遍的方式处理数据的效率已经严重不足，需要对数据进行专有算法优化，根据数据类型的不同和性能指标的要求做定制化的方案。此数据为纯数字，可以通过数组索引对大量数据快速去重。

原理为通过原始数字数据作为数组的索引值访问数组，访问过的数组元素复制为1，没访问过的数组元素值为`null`，在进行一遍数据操作够，在对数据元素值进行判断，便可以进行去重工作。

```
const users = [1,2,3,4,5,6,7,8,9,1,1,1,2,3,5,6];

let max = 0;
const targetArray = [];

for(let i=0;i<users.length;i++){
	targetArray[users[i]] = 1;
	if(max<users[i]){
		max = users[i];
	}
}

const results = [];
for(let i=0;i<=max;i++){
	if(targetArrar[i] == 1){
		results.push(i);
	}
}

console.log(results);
```
### 项目总结

本项目实现过程需要根据数据量级的大小和数据类型的不同，定制化不同的算法以适应对数据处理效率和性能的要求。