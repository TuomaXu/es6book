# 第6章 函数

我们知道圆的面积计算公式为：


S = $πr^2$

当我们知道半径`r`的值时，就可以根据公式计算出面积。假设我们需要计算3个不同大小的圆的面积：

```
let r1 = 12.34;
let r2 = 9.08;
let r3 = 73.1;
let s1 = 3.14 * r1 * r1;
let s2 = 3.14 * r2 * r2;
let s3 = 3.14 * r3 * r3;
```

当代码出现有规律的重复的时候，你就需要当心了，每次写`3.14 * x * x`不仅很麻烦，而且，如果要把`3.14`改成`3.14159265359`的时候，得全部替换。

有了函数，我们就不再每次写`s = 3.14 * x * x，`而是写成更有意义的函数调用`s = area_of_circle(x)`，而函数`area_of_circle`本身只需要写一次，就可以多次调用。

基本上所有的高级语言都支持函数，JavaScript也不例外。JavaScript的函数不但是“头等公民”，而且可以像变量一样使用，具有非常强大的抽象能力。

抽象是数学中非常常见的概念。举个例子：

计算数列的和，比如：`1 + 2 + 3 + ... + 100`，写起来十分不方便，于是数学家发明了求和符号`∑`，可以把`1 + 2 + 3 + ... + 100`记作：

$$\sum_{n=1}^{100}n$$

这种抽象记法非常强大，因为我们看到 ∑ 就可以理解成求和，而不是还原成低级的加法运算。

而且，这种抽象记法是可扩展的，比如：

$$\sum_{n=1}^{100}(n^2+1)$$

还原成加法运算就变成了：

```
(1 x 1 + 1) + (2 x 2 + 1) + (3 x 3 + 1) + ... + (100 x 100 + 1)
```

可见，借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。

写计算机程序也是一样，函数就是最基本的一种代码抽象的方式。



## 6.1 函数基础

函数由函数定义和函数调用两部分组成，应首先定义函数，然后再进行调用，以养成良好的编程习惯。
函数的定义应使用关键字 function，其语法规则如下：```
function funcName () {	statements;}
```函数的各部分含义如下：* funcName 为函数名，函数名可由开发者自行定义，与变量的命名规则基本相同；
* statements 是函数体，规定了函数的功能，本质上相当于一个脚本程序；

例如：

```
function logStar(){
	console.log('***')
}
```

定义函数的代码并不会运行。需要调用函数才可以运行函数体中的代码。在函数定义结束之后的代码空间中，便可以调用该函数。

调用函数的方法即`函数名()`的方式。

```
logStar();
```

我们看如下代码：

```
console.log(1);

function logStar(){
	console.log('***')
}

console.log(2);

logStar();

console.log(3);
```
这段代码的运行结果为

```
1
2
***
3
```
可以看出，代码默认是自上而下的一行一行的运行。但函数定义中函数体的代码并不会运行，只有在函数调用时，函数体的代码才真正运行。且函数可以多次调用，每次调用的结果相互独立。

## 6.2 函数参数与返回值

### 6.2.1 函数参数

在定义函数时，可以在函数名后面的括号中定义多个变量，变量间用逗号分隔。这些变量称为函数参数。

在函数体中，可以直接使用这些函数参数。

```
function add(x,y){
	const sum = x + y;
	console.log(sum);
}
```
参数变量的值由函数调用时指定，根据位置对应关系赋值。

```
add(1,2);
```
如此调用时，函数的第一个参数x的值为1，第二个参数y的值为2；

这里需要强调**函数参数复制只与位置相关，和变量名无关**

阅读如下代码：

```
function funcA(x,y){
	console.log(x);
	console.log(y);
}

const x = 1;
const y = 2;

funcA(y,x);
```

以上代码运行结果为：`2  1`。在函数调用时，将第一个参数位置上的y复制给函数的第一个参数x，以位置关系进行对应赋值。

在使用函数参数时，需要注意**函数参数的传递过程为值复制过程。**

在看下面代码

```
function funcX(x){
	x = 0;
}

let x = 1;
funcX(x);
console.log(x);
```
以上代码运行结果为:`1`。

这里函数中的变量`x`和函数外的变量`x`是两个变量，在函数调用过程中，仅将一个变量的值复制到另一个变量，之后这两个变量便在无联系。所以改变函数内的变量不会影响函数外变量的值。

JavaScript语言允许在定义函数参数时指定函数参数的默认值：

```
function logX(x = 0){
	console.log(x);
}
```
在调用函数时，如没有给定函数参数值，函数即使用默认值作为函数参数。

```
logX();//输出0

logX(1);//输出1
```

### 6.2.2 函数返回值

JavaScript语言中，函数可以通过`return`关键字返回其内部的数据，作为函数表达式的值。

例如：

```
function add(x,y){
	const sum = x + y;
	return sum;
}

const s = add(1,2);
console.log(s);
```
在上述代码中，函数表达式`add(1,2)`的值由函数体中的`return`决定。

`return`不仅提供函数表达式的值，还有结束函数的作用。在没有`return`的函数中，函数运行到大括号结束。但如遇到`return`函数也随之结束，即`return`后面的语句不会执行。

例如：

```
function funcA(){
	console.log(1);
	return 0;
	console.log(2);
}

const r = funcA();
```
以上代码运行结果为：`1`。因`return`关键字提前结束函数。

```
function funcB(){
	return 0;
	return 1;
}
const r = funcB();
console.log(r);
```

以上代码运行结果为：`0`,因第一个`return`决定函数表达式为`0`且结束函数，第二个`return`未运行。


如果函数可能返回多种不同结果，可以使用分支语句。

```
function funcC(x){
	if(x >= 0){
		return '输入参数为正数';
	} else {
		return '输入参数为负数';
	}
}

funcC(1);
funcC(-1);
```
以上运行结果为

```
输入参数为正数
输入参数为负数
```


## 6.3 函数作用域

在JavaScript语言中，函数和变量具有同样的作用域特性，在相同作用域下的的函数体内部可以访问外部的变量。但函数参数和变量名相同时，函数体内部无法访问外包同名变量。

看如下代码的区别：

```
function funcA(x){
	x++;
}

let x = 1;
funcA(x);
console.log(x);
```
此代码运行结果为:`1`

```
function funcA(){
	x++;
}

let x = 1;
funcA(x);
console.log(x);
```
此代码运行结果为:`2`

以上两段代码的区别就是在函数中定义了一个与外部变量同名的参数。在有这个参数时，函数体内部访问的是这个参数，和外部变量无关。在这个参数不存在时，根据作用域的规则，函数体内部可以访问到外部变量。

**通常我们规定，不允许在函数体内部修改外部变量的值，但可以读取外部变量的值，以免产生很多意想不到的错误**

## 6.4 箭头函数

ES6增加箭头函数特性，通过箭头语法声明一个函数，此函数没有函数名，只有参数和函数体。

```
(x,y)=>{
	return x + y;
}
```

定义好的箭头函数不能直接使用，需要借助变量才能够调用箭头函数。

```
//将箭头函数赋值给一个变量
const aFunc = (x)=>{
	console.log(x);
}
//通过储存箭头函数的变量调用该箭头函数

aFunc(1);//输出：1

```

## 6.5 函数对象

在JavaScript中，变量可以储存一个值，一个对象和一个数组。同样变量还可以储存一个函数，储存函数的变量，我们称之为函数对象。

创建函数对象有两种方式：

* 通过箭头函数创建函数对象
* 通过普通函数创建函数对象

```
//将定义好的箭头函数赋值给一个变量，这个变量即成为函数对象
const funcObj1 = (x)=>{
	console.log(x);
}

function func2(x){
	console.log(x);
}

//将一个定义好的普通函数的函数名赋值给一个变量，
//这个变量也为函数对象
const funcObj2 = func2;

```

通过函数对象可以调用其储存的函数体，并传递参数接收返回值

```
const func1 = ()=>{
	console.log('test1');
}

func1();//输出 test1

```

```
const func2 = (x)=>{
	console.log(x);
}

func2(11);//输出 11
```

```
const func3 = (x,y)=>{
	return x+y;
}

const sum = func3(1,2);
console.log(sum);//输出 3
```

## 6.6 高阶函数

高阶函数本质为函数，只是函数参数的类型中含有函数对象。例如：

```
function func1(f1){
	f1();
}
```
在JavaScript定义函数时，无需对函数参数的类型进行声明，所有该函数参数是否为函数对象还是普通对象，需要通过阅读函数体代码或者注释进行。

在函数体内，有对函数参数进行调用的语句(参数后加了一对小括号)，那么可以说明，该参数为函数对象，此函数为高阶函数，我们可以简单说，高阶函数就是调用函数对象的函数。

```
//创建一个函数对象
const f = ()=>{
	console.log('hello');
}

//通过高阶函数func1调用函数对象f
func1(f);//输出结果  hello
```

所以，高阶函数本质是一个非常简单的概念，也很好掌握，关键难度在与应用场景。

大家看到现在可能会有一个疑问，一个函数对象，在代码中，可以直接调用，但为什么要使用一个高阶函数进行调用，为什么要使用这么麻烦的方式？

解答这个问题，我们需要先引出更复杂的需求。在上述打印`hello`的案例中，使用高阶函数确实是一个画蛇添足的过程，但是在遇到复杂问题时，高阶函数是一个非常好的工具。


### 6.6.1 高阶函数使用场景1：对重复过程进行封装


首先我们来说重复过程，这里说的不是一件事的重复过程，而是一类事的重复过程。

例如，对数组进行排序，数组培训的步骤非常多，而且不同数组，不同培训规则的代码也不一样。


```
//用冒泡法对数组arr1进行升序排列
const arr1 = [1,5,2,4,3];

for(let i=0;i<arr1.length-1;i++)    
{
	for(let j=i+1;j<i<arr1.length;j++) {
		//升序or降序
		if(a[j-1]>a[j]) {  
			let t=a[j];  
			a[j]=a[j+1];  
			a[j+1]=t; 
		} 
	}  
}  
```

```
//用冒泡法对数组arr1进行降序排列
const arr1 = [1,5,2,4,3];

for(let i=0;i<arr1.length-1;i++)    
{
	for(let j=i+1;j<i<arr1.length;j++) {
		//升序or降序
		if(a[j-1]<a[j]) {  
			let t=a[j];  
			a[j]=a[j+1];  
			a[j+1]=t; 
		} 
	}  
}  
```
通过阅读这两个排序代码，我们发现排序操作的过程很多，但大多都一样，只有一步不同，就是对升序还是降序的控制语句。

**这种的情况，我们就可以使用高阶函数，将排序这一类事物的相同操作部分进行封装，而不同操作部分定义为一个函数对象，其具体操作有使用者编写**

定义高阶函数，封装操作过程

```
function sort(arr,f){
	for(let i=0;i<arr1.length-1;i++)    
	{
		for(let j=i+1;j<i<arr1.length;j++) {
			//升序or降序,通过调用函数对象f进行获取
			//函数对象f由此函数使用者提供
			const result = f(a[j-1],a[j]);
			if(result) {  
				let t=a[j];  
				a[j]=a[j+1];  
				a[j+1]=t; 
			} 
		}  
	} 
	return arr;
}
```

使用高阶函数

```
//构造函数对象，封装操作过程，指定排序规则为升序
const func = (x,y)=>{
	return x>y;
}
//准备数据
const arr = [1,2,3,4];
//调用高阶函数，传入函数对象
const s_arr = sort(arr,func);
```
通过高阶函数封装了数组的排序过程，在使用其对数组进行排序时，只需要制定排序规则即可。


### 6.6.2，高阶函数使用场景2：事件接口

在讲解事件回调接口之前，我们首先看一个简单的案例

```
//案例1
//创建一个函数，打印1,2,3三个数

function log(){
	console.log(1);
	console.log(2);
	console.log(3);
}

log();//输出 1 2 3
```

这个案例比较简单，就是通过函数封装了三个输出操作。我们继续看下一个少难一点的案例

```
//案例2
//创建一个函数，先打印1，在打印一个x的值，在打印3
//x的值在创建函数的时候不知道是多少

function log(x){
	console.log(1);
	console.log(x);
	console.log(3);
}
```

我们看案例1和案例2的区别，这两个案例都是通过一个函数封装操作，但案例中的每个操作都是明确的，在编程的时候已知所有信息，而案例2中的操作，编程的时候，有部分信息是未知的。

但案例2我们仍然可以处理，因为位置的是一个值，我们可以用变量去表示这个值，在使用`log`函数时，为这个变量赋值即可。

案例1的编程模式，我们称之为**静态编程**，即编程的时候已知所有信息。案例2的编程模式，我们称之为**动态编程**，即编程的时候有部分信息未知。

通过变量，我们可以处理值未知的动态问题。例如

```
//构造一个函数，求两个数的和
//在编程函数是，不知道是哪两个数，是动态编程
//所以我们使用变量进行处理，定义x，y两个变量作为函数参数
function add(x,y){
	return x+y;
}
```

同时，通过函数对象，我们可以处理未知事件问题，例如：

```
//构造一个函数，要求如下：
//首先打印一个1，然后执行一个操作，然后打印一个2
//执行的操作在编程中未知，我们用一个函数对象表示这个未知的操作

function doSomething(func){
	console.log(1);
	func();//调用函数对象，即表示执行函数对象中封装的操作
	console.log(3);
}
```

使用这个函数执行相应事件

```
//首先构造函数对象，封装所要执行的事件
const f = ()=>{
	console.log(2);
}
//调用函数执行
doSomething(f);//输出1 2 3
```
看到这里，大家心里可能会产生一个疑问。

```
function log(){
	console.log(1);
	console.log(2);
	console.log(3);
}

log();//输出 1 2 3
```
```
function doSomething(func){
	console.log(1);
	func();//调用函数对象，即表示执行函数对象中封装的操作
	console.log(3);
}

const f = ()=>{
	console.log(2);
}

doSomething(f);//输出1 2 3
```
以上两段代码都是输出1 2 3 为何下面的代码这么复杂。

首先我们看下面一段代码，可是分为两个部分

```
function doSomething(func){
	console.log(1);
	func();//调用函数对象，即表示执行函数对象中封装的操作
	console.log(3);
}
```
```
const f = ()=>{
	console.log(2);
}

doSomething(f);//输出1 2 3
```
分为这两个部分之后，我们在来看，如果现在需求变化了，我们需要输出1 5 3

那么，如果是原来的代码，我们需要对其函数内部进行修改

```
function log(){
	console.log(1);
	console.log(5);
	console.log(3);
}
```
而分成两段的复杂代码，我们只需要重写下一段代码即可实现

```
const f = ()=>{
	console.log(5);
}

doSomething(f);//输出1 5 3
```
而上面一段代码无需进行任何修改。

这样不需要修改代码，而能够使其适应各种使用场景的基础代码是非常重要的。

因为我们在真实的开发中，不是从零开始开发所有的东西，我们会使用各种框架，而框架中会提供各种基础操作，我们只需要在框架基础操作上面定制我们所需要的功能。这种定制就是基于此知识点实现的。

例如我们以后会使用ReactNative框架，其提供了一个按钮组件，在编写按钮组件时，编写人员并不知道你会在按钮点击时执行什么样的代码，但这并不影响按钮组件的开发，开发人员只需要通过一个函数对象做为未知事件的变量。

例如：

```
ReactNative API
//onClick为一个函数对象，当按钮被点击时被执行
button(onClick);
```
那么我们就可以使用该按钮

```
const loginAciton = ()=>{
	console.log('登录');//模拟登录
}
button(loginAciton);
```
```
const postAciton = ()=>{
	console.log('发微博');//模拟登录
}
button(postAciton);
```
虽然点击按钮执行的是不同的功能，但是我们不需要更改按钮的任何一行代码。**这个函数的参数就是事件接口，本质为一个函数对象的形参。**
